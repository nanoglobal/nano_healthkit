// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos/healthdata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum HealthTypes: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case workoutMain // = 0
  case categorySleepAnalysis // = 1
  case categoryAppleStandHour // = 2
  case categoryCervicalMucusQuality // = 3
  case categoryOvulationTestResult // = 4
  case categoryMenstrualFlow // = 5
  case categoryIntermenstrualBleeding // = 6
  case categorySexualActivity // = 7
  case categoryMindfulSession // = 8
  case categoryHighHeartRateEvent // = 9
  case categoryLowHeartRateEvent // = 10
  case categoryIrregularHeartRhythmEvent // = 11
  case categoryAudioExposureEvent // = 12
  case categoryToothbrushingEvent // = 13
  case quantityBodyMassIndex // = 14
  case quantityBodyFatPercentage // = 15
  case quantityHeight // = 16
  case quantityBodyMass // = 17
  case quantityLeanBodyMass // = 18
  case quantityStepCount // = 19
  case quantityDistanceWalkingRunning // = 20
  case quantityDistanceCycling // = 21
  case quantityBasalEnergyBurned // = 22
  case quantityActiveEnergyBurned // = 23
  case quantityFlightsClimbed // = 24
  case quantityNikeFuel // = 25
  case quantityHeartRate // = 26
  case quantityBodyTemperature // = 27
  case quantityBasalBodyTemperature // = 28
  case quantityBloodPressureSystolic // = 29
  case quantityBloodPressureDiastolic // = 30
  case quantityRespiratoryRate // = 31
  case quantityOxygenSaturation // = 32
  case quantityPeripheralPerfusionIndex // = 33
  case quantityBloodGlucose // = 34
  case quantityNumberOfTimesFallen // = 35
  case quantityElectrodermalActivity // = 36
  case quantityInhalerUsage // = 37
  case quantityBloodAlcoholContent // = 38
  case quantityForcedVitalCapacity // = 39
  case quantityForcedExpiratoryVolume1 // = 40
  case quantityPeakExpiratoryFlowRate // = 41
  case quantityDietaryFatTotal // = 42
  case quantityDietaryFatPolyunsaturated // = 43
  case quantityDietaryFatMonounsaturated // = 44
  case quantityDietaryFatSaturated // = 45
  case quantityDietaryCholesterol // = 46
  case quantityDietarySodium // = 47
  case quantityDietaryCarbohydrates // = 48
  case quantityDietaryFiber // = 49
  case quantityDietarySugar // = 50
  case quantityDietaryEnergyConsumed // = 51
  case quantityDietaryProtein // = 52
  case quantityDietaryVitaminA // = 53
  case quantityDietaryVitaminB6 // = 54
  case quantityDietaryVitaminB12 // = 55
  case quantityDietaryVitaminC // = 56
  case quantityDietaryVitaminD // = 57
  case quantityDietaryVitaminE // = 58
  case quantityDietaryVitaminK // = 59
  case quantityDietaryCalcium // = 60
  case quantityDietaryIron // = 61
  case quantityDietaryThiamin // = 62
  case quantityDietaryRiboflavin // = 63
  case quantityDietaryNiacin // = 64
  case quantityDietaryFolate // = 65
  case quantityDietaryBiotin // = 66
  case quantityDietaryPantothenicAcid // = 67
  case quantityDietaryPhosphorus // = 68
  case quantityDietaryIodine // = 69
  case quantityDietaryMagnesium // = 70
  case quantityDietaryZinc // = 71
  case quantityDietarySelenium // = 72
  case quantityDietaryCopper // = 73
  case quantityDietaryManganese // = 74
  case quantityDietaryChromium // = 75
  case quantityDietaryMolybdenum // = 76
  case quantityDietaryChloride // = 77
  case quantityDietaryPotassium // = 78
  case quantityDietaryCaffeine // = 79
  case quantityDietaryWater // = 80
  case quantityUvExposure // = 81
  case quantityAppleExerciseTime // = 82
  case quantityDistanceWheelchair // = 83
  case quantityPushCount // = 84
  case quantityDistanceSwimming // = 85
  case quantitySwimmingStrokeCount // = 86
  case quantityWaistCircumference // = 87
  case quantityVo2Max // = 88
  case quantityRestingHeartRate // = 89
  case quantityWalkingHeartRateAverage // = 90
  case quantityHeartRateVariabilitySdnn // = 91
  case quantityInsulinDelivery // = 92
  case quantityDistanceDownhillSnowSports // = 93
  case quantityAppleStandTime // = 94
  case quantityEnvironmentalAudioExposure // = 95
  case quantityHeadphoneAudioExposure // = 96
  case characteristicBiologicalSex // = 97
  case characteristicBloodType // = 98
  case characteristicDateOfBirth // = 99
  case characteristicFitzpatrickSkinType // = 100
  case characteristicWheelchairUse // = 101
  case clinicalAllergyRecord // = 102
  case clinicalConditionRecord // = 103
  case clinicalImmunizationRecord // = 104
  case clinicalLabResultRecord // = 105
  case clinicalMedicationRecord // = 106
  case clinicalProcedureRecord // = 107
  case clinicalVitalSignRecord // = 108
  case documentCda // = 109
  case correlationBloodPressure // = 110
  case correlationFood // = 111
  case UNRECOGNIZED(Int)

  init() {
    self = .workoutMain
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .workoutMain
    case 1: self = .categorySleepAnalysis
    case 2: self = .categoryAppleStandHour
    case 3: self = .categoryCervicalMucusQuality
    case 4: self = .categoryOvulationTestResult
    case 5: self = .categoryMenstrualFlow
    case 6: self = .categoryIntermenstrualBleeding
    case 7: self = .categorySexualActivity
    case 8: self = .categoryMindfulSession
    case 9: self = .categoryHighHeartRateEvent
    case 10: self = .categoryLowHeartRateEvent
    case 11: self = .categoryIrregularHeartRhythmEvent
    case 12: self = .categoryAudioExposureEvent
    case 13: self = .categoryToothbrushingEvent
    case 14: self = .quantityBodyMassIndex
    case 15: self = .quantityBodyFatPercentage
    case 16: self = .quantityHeight
    case 17: self = .quantityBodyMass
    case 18: self = .quantityLeanBodyMass
    case 19: self = .quantityStepCount
    case 20: self = .quantityDistanceWalkingRunning
    case 21: self = .quantityDistanceCycling
    case 22: self = .quantityBasalEnergyBurned
    case 23: self = .quantityActiveEnergyBurned
    case 24: self = .quantityFlightsClimbed
    case 25: self = .quantityNikeFuel
    case 26: self = .quantityHeartRate
    case 27: self = .quantityBodyTemperature
    case 28: self = .quantityBasalBodyTemperature
    case 29: self = .quantityBloodPressureSystolic
    case 30: self = .quantityBloodPressureDiastolic
    case 31: self = .quantityRespiratoryRate
    case 32: self = .quantityOxygenSaturation
    case 33: self = .quantityPeripheralPerfusionIndex
    case 34: self = .quantityBloodGlucose
    case 35: self = .quantityNumberOfTimesFallen
    case 36: self = .quantityElectrodermalActivity
    case 37: self = .quantityInhalerUsage
    case 38: self = .quantityBloodAlcoholContent
    case 39: self = .quantityForcedVitalCapacity
    case 40: self = .quantityForcedExpiratoryVolume1
    case 41: self = .quantityPeakExpiratoryFlowRate
    case 42: self = .quantityDietaryFatTotal
    case 43: self = .quantityDietaryFatPolyunsaturated
    case 44: self = .quantityDietaryFatMonounsaturated
    case 45: self = .quantityDietaryFatSaturated
    case 46: self = .quantityDietaryCholesterol
    case 47: self = .quantityDietarySodium
    case 48: self = .quantityDietaryCarbohydrates
    case 49: self = .quantityDietaryFiber
    case 50: self = .quantityDietarySugar
    case 51: self = .quantityDietaryEnergyConsumed
    case 52: self = .quantityDietaryProtein
    case 53: self = .quantityDietaryVitaminA
    case 54: self = .quantityDietaryVitaminB6
    case 55: self = .quantityDietaryVitaminB12
    case 56: self = .quantityDietaryVitaminC
    case 57: self = .quantityDietaryVitaminD
    case 58: self = .quantityDietaryVitaminE
    case 59: self = .quantityDietaryVitaminK
    case 60: self = .quantityDietaryCalcium
    case 61: self = .quantityDietaryIron
    case 62: self = .quantityDietaryThiamin
    case 63: self = .quantityDietaryRiboflavin
    case 64: self = .quantityDietaryNiacin
    case 65: self = .quantityDietaryFolate
    case 66: self = .quantityDietaryBiotin
    case 67: self = .quantityDietaryPantothenicAcid
    case 68: self = .quantityDietaryPhosphorus
    case 69: self = .quantityDietaryIodine
    case 70: self = .quantityDietaryMagnesium
    case 71: self = .quantityDietaryZinc
    case 72: self = .quantityDietarySelenium
    case 73: self = .quantityDietaryCopper
    case 74: self = .quantityDietaryManganese
    case 75: self = .quantityDietaryChromium
    case 76: self = .quantityDietaryMolybdenum
    case 77: self = .quantityDietaryChloride
    case 78: self = .quantityDietaryPotassium
    case 79: self = .quantityDietaryCaffeine
    case 80: self = .quantityDietaryWater
    case 81: self = .quantityUvExposure
    case 82: self = .quantityAppleExerciseTime
    case 83: self = .quantityDistanceWheelchair
    case 84: self = .quantityPushCount
    case 85: self = .quantityDistanceSwimming
    case 86: self = .quantitySwimmingStrokeCount
    case 87: self = .quantityWaistCircumference
    case 88: self = .quantityVo2Max
    case 89: self = .quantityRestingHeartRate
    case 90: self = .quantityWalkingHeartRateAverage
    case 91: self = .quantityHeartRateVariabilitySdnn
    case 92: self = .quantityInsulinDelivery
    case 93: self = .quantityDistanceDownhillSnowSports
    case 94: self = .quantityAppleStandTime
    case 95: self = .quantityEnvironmentalAudioExposure
    case 96: self = .quantityHeadphoneAudioExposure
    case 97: self = .characteristicBiologicalSex
    case 98: self = .characteristicBloodType
    case 99: self = .characteristicDateOfBirth
    case 100: self = .characteristicFitzpatrickSkinType
    case 101: self = .characteristicWheelchairUse
    case 102: self = .clinicalAllergyRecord
    case 103: self = .clinicalConditionRecord
    case 104: self = .clinicalImmunizationRecord
    case 105: self = .clinicalLabResultRecord
    case 106: self = .clinicalMedicationRecord
    case 107: self = .clinicalProcedureRecord
    case 108: self = .clinicalVitalSignRecord
    case 109: self = .documentCda
    case 110: self = .correlationBloodPressure
    case 111: self = .correlationFood
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .workoutMain: return 0
    case .categorySleepAnalysis: return 1
    case .categoryAppleStandHour: return 2
    case .categoryCervicalMucusQuality: return 3
    case .categoryOvulationTestResult: return 4
    case .categoryMenstrualFlow: return 5
    case .categoryIntermenstrualBleeding: return 6
    case .categorySexualActivity: return 7
    case .categoryMindfulSession: return 8
    case .categoryHighHeartRateEvent: return 9
    case .categoryLowHeartRateEvent: return 10
    case .categoryIrregularHeartRhythmEvent: return 11
    case .categoryAudioExposureEvent: return 12
    case .categoryToothbrushingEvent: return 13
    case .quantityBodyMassIndex: return 14
    case .quantityBodyFatPercentage: return 15
    case .quantityHeight: return 16
    case .quantityBodyMass: return 17
    case .quantityLeanBodyMass: return 18
    case .quantityStepCount: return 19
    case .quantityDistanceWalkingRunning: return 20
    case .quantityDistanceCycling: return 21
    case .quantityBasalEnergyBurned: return 22
    case .quantityActiveEnergyBurned: return 23
    case .quantityFlightsClimbed: return 24
    case .quantityNikeFuel: return 25
    case .quantityHeartRate: return 26
    case .quantityBodyTemperature: return 27
    case .quantityBasalBodyTemperature: return 28
    case .quantityBloodPressureSystolic: return 29
    case .quantityBloodPressureDiastolic: return 30
    case .quantityRespiratoryRate: return 31
    case .quantityOxygenSaturation: return 32
    case .quantityPeripheralPerfusionIndex: return 33
    case .quantityBloodGlucose: return 34
    case .quantityNumberOfTimesFallen: return 35
    case .quantityElectrodermalActivity: return 36
    case .quantityInhalerUsage: return 37
    case .quantityBloodAlcoholContent: return 38
    case .quantityForcedVitalCapacity: return 39
    case .quantityForcedExpiratoryVolume1: return 40
    case .quantityPeakExpiratoryFlowRate: return 41
    case .quantityDietaryFatTotal: return 42
    case .quantityDietaryFatPolyunsaturated: return 43
    case .quantityDietaryFatMonounsaturated: return 44
    case .quantityDietaryFatSaturated: return 45
    case .quantityDietaryCholesterol: return 46
    case .quantityDietarySodium: return 47
    case .quantityDietaryCarbohydrates: return 48
    case .quantityDietaryFiber: return 49
    case .quantityDietarySugar: return 50
    case .quantityDietaryEnergyConsumed: return 51
    case .quantityDietaryProtein: return 52
    case .quantityDietaryVitaminA: return 53
    case .quantityDietaryVitaminB6: return 54
    case .quantityDietaryVitaminB12: return 55
    case .quantityDietaryVitaminC: return 56
    case .quantityDietaryVitaminD: return 57
    case .quantityDietaryVitaminE: return 58
    case .quantityDietaryVitaminK: return 59
    case .quantityDietaryCalcium: return 60
    case .quantityDietaryIron: return 61
    case .quantityDietaryThiamin: return 62
    case .quantityDietaryRiboflavin: return 63
    case .quantityDietaryNiacin: return 64
    case .quantityDietaryFolate: return 65
    case .quantityDietaryBiotin: return 66
    case .quantityDietaryPantothenicAcid: return 67
    case .quantityDietaryPhosphorus: return 68
    case .quantityDietaryIodine: return 69
    case .quantityDietaryMagnesium: return 70
    case .quantityDietaryZinc: return 71
    case .quantityDietarySelenium: return 72
    case .quantityDietaryCopper: return 73
    case .quantityDietaryManganese: return 74
    case .quantityDietaryChromium: return 75
    case .quantityDietaryMolybdenum: return 76
    case .quantityDietaryChloride: return 77
    case .quantityDietaryPotassium: return 78
    case .quantityDietaryCaffeine: return 79
    case .quantityDietaryWater: return 80
    case .quantityUvExposure: return 81
    case .quantityAppleExerciseTime: return 82
    case .quantityDistanceWheelchair: return 83
    case .quantityPushCount: return 84
    case .quantityDistanceSwimming: return 85
    case .quantitySwimmingStrokeCount: return 86
    case .quantityWaistCircumference: return 87
    case .quantityVo2Max: return 88
    case .quantityRestingHeartRate: return 89
    case .quantityWalkingHeartRateAverage: return 90
    case .quantityHeartRateVariabilitySdnn: return 91
    case .quantityInsulinDelivery: return 92
    case .quantityDistanceDownhillSnowSports: return 93
    case .quantityAppleStandTime: return 94
    case .quantityEnvironmentalAudioExposure: return 95
    case .quantityHeadphoneAudioExposure: return 96
    case .characteristicBiologicalSex: return 97
    case .characteristicBloodType: return 98
    case .characteristicDateOfBirth: return 99
    case .characteristicFitzpatrickSkinType: return 100
    case .characteristicWheelchairUse: return 101
    case .clinicalAllergyRecord: return 102
    case .clinicalConditionRecord: return 103
    case .clinicalImmunizationRecord: return 104
    case .clinicalLabResultRecord: return 105
    case .clinicalMedicationRecord: return 106
    case .clinicalProcedureRecord: return 107
    case .clinicalVitalSignRecord: return 108
    case .documentCda: return 109
    case .correlationBloodPressure: return 110
    case .correlationFood: return 111
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HealthTypes: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [HealthTypes] = [
    .workoutMain,
    .categorySleepAnalysis,
    .categoryAppleStandHour,
    .categoryCervicalMucusQuality,
    .categoryOvulationTestResult,
    .categoryMenstrualFlow,
    .categoryIntermenstrualBleeding,
    .categorySexualActivity,
    .categoryMindfulSession,
    .categoryHighHeartRateEvent,
    .categoryLowHeartRateEvent,
    .categoryIrregularHeartRhythmEvent,
    .categoryAudioExposureEvent,
    .categoryToothbrushingEvent,
    .quantityBodyMassIndex,
    .quantityBodyFatPercentage,
    .quantityHeight,
    .quantityBodyMass,
    .quantityLeanBodyMass,
    .quantityStepCount,
    .quantityDistanceWalkingRunning,
    .quantityDistanceCycling,
    .quantityBasalEnergyBurned,
    .quantityActiveEnergyBurned,
    .quantityFlightsClimbed,
    .quantityNikeFuel,
    .quantityHeartRate,
    .quantityBodyTemperature,
    .quantityBasalBodyTemperature,
    .quantityBloodPressureSystolic,
    .quantityBloodPressureDiastolic,
    .quantityRespiratoryRate,
    .quantityOxygenSaturation,
    .quantityPeripheralPerfusionIndex,
    .quantityBloodGlucose,
    .quantityNumberOfTimesFallen,
    .quantityElectrodermalActivity,
    .quantityInhalerUsage,
    .quantityBloodAlcoholContent,
    .quantityForcedVitalCapacity,
    .quantityForcedExpiratoryVolume1,
    .quantityPeakExpiratoryFlowRate,
    .quantityDietaryFatTotal,
    .quantityDietaryFatPolyunsaturated,
    .quantityDietaryFatMonounsaturated,
    .quantityDietaryFatSaturated,
    .quantityDietaryCholesterol,
    .quantityDietarySodium,
    .quantityDietaryCarbohydrates,
    .quantityDietaryFiber,
    .quantityDietarySugar,
    .quantityDietaryEnergyConsumed,
    .quantityDietaryProtein,
    .quantityDietaryVitaminA,
    .quantityDietaryVitaminB6,
    .quantityDietaryVitaminB12,
    .quantityDietaryVitaminC,
    .quantityDietaryVitaminD,
    .quantityDietaryVitaminE,
    .quantityDietaryVitaminK,
    .quantityDietaryCalcium,
    .quantityDietaryIron,
    .quantityDietaryThiamin,
    .quantityDietaryRiboflavin,
    .quantityDietaryNiacin,
    .quantityDietaryFolate,
    .quantityDietaryBiotin,
    .quantityDietaryPantothenicAcid,
    .quantityDietaryPhosphorus,
    .quantityDietaryIodine,
    .quantityDietaryMagnesium,
    .quantityDietaryZinc,
    .quantityDietarySelenium,
    .quantityDietaryCopper,
    .quantityDietaryManganese,
    .quantityDietaryChromium,
    .quantityDietaryMolybdenum,
    .quantityDietaryChloride,
    .quantityDietaryPotassium,
    .quantityDietaryCaffeine,
    .quantityDietaryWater,
    .quantityUvExposure,
    .quantityAppleExerciseTime,
    .quantityDistanceWheelchair,
    .quantityPushCount,
    .quantityDistanceSwimming,
    .quantitySwimmingStrokeCount,
    .quantityWaistCircumference,
    .quantityVo2Max,
    .quantityRestingHeartRate,
    .quantityWalkingHeartRateAverage,
    .quantityHeartRateVariabilitySdnn,
    .quantityInsulinDelivery,
    .quantityDistanceDownhillSnowSports,
    .quantityAppleStandTime,
    .quantityEnvironmentalAudioExposure,
    .quantityHeadphoneAudioExposure,
    .characteristicBiologicalSex,
    .characteristicBloodType,
    .characteristicDateOfBirth,
    .characteristicFitzpatrickSkinType,
    .characteristicWheelchairUse,
    .clinicalAllergyRecord,
    .clinicalConditionRecord,
    .clinicalImmunizationRecord,
    .clinicalLabResultRecord,
    .clinicalMedicationRecord,
    .clinicalProcedureRecord,
    .clinicalVitalSignRecord,
    .documentCda,
    .correlationBloodPressure,
    .correlationFood,
  ]
}

#endif  // swift(>=4.2)

enum RequestSorting: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case descendingStartDate // = 0
  case ascendingStartDate // = 1
  case ascendingEndDate // = 2
  case descendingEndDate // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .descendingStartDate
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .descendingStartDate
    case 1: self = .ascendingStartDate
    case 2: self = .ascendingEndDate
    case 3: self = .descendingEndDate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .descendingStartDate: return 0
    case .ascendingStartDate: return 1
    case .ascendingEndDate: return 2
    case .descendingEndDate: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension RequestSorting: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RequestSorting] = [
    .descendingStartDate,
    .ascendingStartDate,
    .ascendingEndDate,
    .descendingEndDate,
  ]
}

#endif  // swift(>=4.2)

enum StatisticsOptions: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case discreteAverage // = 0
  case discreteMin // = 1
  case discreteMax // = 2
  case cumulativeSum // = 3
  case mostRecent // = 4
  case duration // = 5
  case separateBySource // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .discreteAverage
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .discreteAverage
    case 1: self = .discreteMin
    case 2: self = .discreteMax
    case 3: self = .cumulativeSum
    case 4: self = .mostRecent
    case 5: self = .duration
    case 6: self = .separateBySource
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .discreteAverage: return 0
    case .discreteMin: return 1
    case .discreteMax: return 2
    case .cumulativeSum: return 3
    case .mostRecent: return 4
    case .duration: return 5
    case .separateBySource: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension StatisticsOptions: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StatisticsOptions] = [
    .discreteAverage,
    .discreteMin,
    .discreteMax,
    .cumulativeSum,
    .mostRecent,
    .duration,
    .separateBySource,
  ]
}

#endif  // swift(>=4.2)

struct HealthTypeList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var types: [HealthTypes] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HealthDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HealthTypes = .workoutMain

  var startDate: String = String()

  var endDate: String = String()

  var limit: Int32 = 0

  var sorting: RequestSorting = .descendingStartDate

  var units: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HealthDataRequestList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requests: [HealthDataRequest] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HealthData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HealthTypes {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var objectType: String {
    get {return _storage._objectType}
    set {_uniqueStorage()._objectType = newValue}
  }

  var startDate: String {
    get {return _storage._startDate}
    set {_uniqueStorage()._startDate = newValue}
  }

  var endDate: String {
    get {return _storage._endDate}
    set {_uniqueStorage()._endDate = newValue}
  }

  var device: String {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  var metadata: String {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var source: SourceRevision {
    get {return _storage._source ?? SourceRevision()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {_uniqueStorage()._source = nil}

  var specificData: OneOf_SpecificData? {
    get {return _storage._specificData}
    set {_uniqueStorage()._specificData = newValue}
  }

  var emptyData: EmptySpecificData {
    get {
      if case .emptyData(let v)? = _storage._specificData {return v}
      return EmptySpecificData()
    }
    set {_uniqueStorage()._specificData = .emptyData(newValue)}
  }

  var quantityData: QuantitySpecificData {
    get {
      if case .quantityData(let v)? = _storage._specificData {return v}
      return QuantitySpecificData()
    }
    set {_uniqueStorage()._specificData = .quantityData(newValue)}
  }

  var categoryData: CategorySpecificData {
    get {
      if case .categoryData(let v)? = _storage._specificData {return v}
      return CategorySpecificData()
    }
    set {_uniqueStorage()._specificData = .categoryData(newValue)}
  }

  var workoutData: WorkoutSpecificData {
    get {
      if case .workoutData(let v)? = _storage._specificData {return v}
      return WorkoutSpecificData()
    }
    set {_uniqueStorage()._specificData = .workoutData(newValue)}
  }

  var characteristicData: CharacteristicSpecificData {
    get {
      if case .characteristicData(let v)? = _storage._specificData {return v}
      return CharacteristicSpecificData()
    }
    set {_uniqueStorage()._specificData = .characteristicData(newValue)}
  }

  var clinicalRecordData: ClinicalRecordSpecificData {
    get {
      if case .clinicalRecordData(let v)? = _storage._specificData {return v}
      return ClinicalRecordSpecificData()
    }
    set {_uniqueStorage()._specificData = .clinicalRecordData(newValue)}
  }

  var documentData: DocumentSpecificData {
    get {
      if case .documentData(let v)? = _storage._specificData {return v}
      return DocumentSpecificData()
    }
    set {_uniqueStorage()._specificData = .documentData(newValue)}
  }

  var correlationData: CorrelationSpecificData {
    get {
      if case .correlationData(let v)? = _storage._specificData {return v}
      return CorrelationSpecificData()
    }
    set {_uniqueStorage()._specificData = .correlationData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_SpecificData: Equatable {
    case emptyData(EmptySpecificData)
    case quantityData(QuantitySpecificData)
    case categoryData(CategorySpecificData)
    case workoutData(WorkoutSpecificData)
    case characteristicData(CharacteristicSpecificData)
    case clinicalRecordData(ClinicalRecordSpecificData)
    case documentData(DocumentSpecificData)
    case correlationData(CorrelationSpecificData)

  #if !swift(>=4.1)
    static func ==(lhs: HealthData.OneOf_SpecificData, rhs: HealthData.OneOf_SpecificData) -> Bool {
      switch (lhs, rhs) {
      case (.emptyData(let l), .emptyData(let r)): return l == r
      case (.quantityData(let l), .quantityData(let r)): return l == r
      case (.categoryData(let l), .categoryData(let r)): return l == r
      case (.workoutData(let l), .workoutData(let r)): return l == r
      case (.characteristicData(let l), .characteristicData(let r)): return l == r
      case (.clinicalRecordData(let l), .clinicalRecordData(let r)): return l == r
      case (.documentData(let l), .documentData(let r)): return l == r
      case (.correlationData(let l), .correlationData(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct HealthDataList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: [HealthData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct EmptySpecificData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct QuantitySpecificData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var count: Int64 = 0

  var quantityUnit: String = String()

  var quantity: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CategorySpecificData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct WorkoutSpecificData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalEnergyBurned: Double = 0

  var totalEnergyBurnedUnit: String = String()

  var totalDistance: Double = 0

  var totalDistanceUnit: String = String()

  var duration: Double = 0

  var activityType: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CharacteristicSpecificData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClinicalRecordSpecificData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var displayName: String = String()

  var fhirResource: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DocumentSpecificData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var authorName: String = String()

  var custodianName: String = String()

  var documentData: String = String()

  var patientName: String = String()

  var title: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CorrelationSpecificData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objects: [HealthData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SourceRevision {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var operatingSystemVersion: String = String()

  var productType: String = String()

  var name: String = String()

  var bundleIdentifier: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StatisticsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HealthTypes = .workoutMain

  var startDate: String = String()

  var endDate: String = String()

  var options: [StatisticsOptions] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StatisticsData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sources: [SourceRevision] {
    get {return _storage._sources}
    set {_uniqueStorage()._sources = newValue}
  }

  var averageQuantity: QuantitySpecificData {
    get {return _storage._averageQuantity ?? QuantitySpecificData()}
    set {_uniqueStorage()._averageQuantity = newValue}
  }
  /// Returns true if `averageQuantity` has been explicitly set.
  var hasAverageQuantity: Bool {return _storage._averageQuantity != nil}
  /// Clears the value of `averageQuantity`. Subsequent reads from it will return its default value.
  mutating func clearAverageQuantity() {_uniqueStorage()._averageQuantity = nil}

  var maximumQuantity: QuantitySpecificData {
    get {return _storage._maximumQuantity ?? QuantitySpecificData()}
    set {_uniqueStorage()._maximumQuantity = newValue}
  }
  /// Returns true if `maximumQuantity` has been explicitly set.
  var hasMaximumQuantity: Bool {return _storage._maximumQuantity != nil}
  /// Clears the value of `maximumQuantity`. Subsequent reads from it will return its default value.
  mutating func clearMaximumQuantity() {_uniqueStorage()._maximumQuantity = nil}

  var minimumQuantity: QuantitySpecificData {
    get {return _storage._minimumQuantity ?? QuantitySpecificData()}
    set {_uniqueStorage()._minimumQuantity = newValue}
  }
  /// Returns true if `minimumQuantity` has been explicitly set.
  var hasMinimumQuantity: Bool {return _storage._minimumQuantity != nil}
  /// Clears the value of `minimumQuantity`. Subsequent reads from it will return its default value.
  mutating func clearMinimumQuantity() {_uniqueStorage()._minimumQuantity = nil}

  var sumQuantity: QuantitySpecificData {
    get {return _storage._sumQuantity ?? QuantitySpecificData()}
    set {_uniqueStorage()._sumQuantity = newValue}
  }
  /// Returns true if `sumQuantity` has been explicitly set.
  var hasSumQuantity: Bool {return _storage._sumQuantity != nil}
  /// Clears the value of `sumQuantity`. Subsequent reads from it will return its default value.
  mutating func clearSumQuantity() {_uniqueStorage()._sumQuantity = nil}

  var duration: QuantitySpecificData {
    get {return _storage._duration ?? QuantitySpecificData()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {_uniqueStorage()._duration = nil}

  var mostRecentQuantity: QuantitySpecificData {
    get {return _storage._mostRecentQuantity ?? QuantitySpecificData()}
    set {_uniqueStorage()._mostRecentQuantity = newValue}
  }
  /// Returns true if `mostRecentQuantity` has been explicitly set.
  var hasMostRecentQuantity: Bool {return _storage._mostRecentQuantity != nil}
  /// Clears the value of `mostRecentQuantity`. Subsequent reads from it will return its default value.
  mutating func clearMostRecentQuantity() {_uniqueStorage()._mostRecentQuantity = nil}

  var mostRecentQuantityDateInterval: StatisticsData.TimeInterval {
    get {return _storage._mostRecentQuantityDateInterval ?? StatisticsData.TimeInterval()}
    set {_uniqueStorage()._mostRecentQuantityDateInterval = newValue}
  }
  /// Returns true if `mostRecentQuantityDateInterval` has been explicitly set.
  var hasMostRecentQuantityDateInterval: Bool {return _storage._mostRecentQuantityDateInterval != nil}
  /// Clears the value of `mostRecentQuantityDateInterval`. Subsequent reads from it will return its default value.
  mutating func clearMostRecentQuantityDateInterval() {_uniqueStorage()._mostRecentQuantityDateInterval = nil}

  var dataInterval: StatisticsData.TimeInterval {
    get {return _storage._dataInterval ?? StatisticsData.TimeInterval()}
    set {_uniqueStorage()._dataInterval = newValue}
  }
  /// Returns true if `dataInterval` has been explicitly set.
  var hasDataInterval: Bool {return _storage._dataInterval != nil}
  /// Clears the value of `dataInterval`. Subsequent reads from it will return its default value.
  mutating func clearDataInterval() {_uniqueStorage()._dataInterval = nil}

  var dataBySource: [StatisticsData.StatisticsDataBySource] {
    get {return _storage._dataBySource}
    set {_uniqueStorage()._dataBySource = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct StatisticsDataBySource {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: SourceRevision {
      get {return _storage._source ?? SourceRevision()}
      set {_uniqueStorage()._source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return _storage._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {_uniqueStorage()._source = nil}

    var data: StatisticsData {
      get {return _storage._data ?? StatisticsData()}
      set {_uniqueStorage()._data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    var hasData: Bool {return _storage._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    mutating func clearData() {_uniqueStorage()._data = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct TimeInterval {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startDate: String = String()

    var endDate: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HealthTypes: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKOUT_MAIN"),
    1: .same(proto: "CATEGORY_SLEEP_ANALYSIS"),
    2: .same(proto: "CATEGORY_APPLE_STAND_HOUR"),
    3: .same(proto: "CATEGORY_CERVICAL_MUCUS_QUALITY"),
    4: .same(proto: "CATEGORY_OVULATION_TEST_RESULT"),
    5: .same(proto: "CATEGORY_MENSTRUAL_FLOW"),
    6: .same(proto: "CATEGORY_INTERMENSTRUAL_BLEEDING"),
    7: .same(proto: "CATEGORY_SEXUAL_ACTIVITY"),
    8: .same(proto: "CATEGORY_MINDFUL_SESSION"),
    9: .same(proto: "CATEGORY_HIGH_HEART_RATE_EVENT"),
    10: .same(proto: "CATEGORY_LOW_HEART_RATE_EVENT"),
    11: .same(proto: "CATEGORY_IRREGULAR_HEART_RHYTHM_EVENT"),
    12: .same(proto: "CATEGORY_AUDIO_EXPOSURE_EVENT"),
    13: .same(proto: "CATEGORY_TOOTHBRUSHING_EVENT"),
    14: .same(proto: "QUANTITY_BODY_MASS_INDEX"),
    15: .same(proto: "QUANTITY_BODY_FAT_PERCENTAGE"),
    16: .same(proto: "QUANTITY_HEIGHT"),
    17: .same(proto: "QUANTITY_BODY_MASS"),
    18: .same(proto: "QUANTITY_LEAN_BODY_MASS"),
    19: .same(proto: "QUANTITY_STEP_COUNT"),
    20: .same(proto: "QUANTITY_DISTANCE_WALKING_RUNNING"),
    21: .same(proto: "QUANTITY_DISTANCE_CYCLING"),
    22: .same(proto: "QUANTITY_BASAL_ENERGY_BURNED"),
    23: .same(proto: "QUANTITY_ACTIVE_ENERGY_BURNED"),
    24: .same(proto: "QUANTITY_FLIGHTS_CLIMBED"),
    25: .same(proto: "QUANTITY_NIKE_FUEL"),
    26: .same(proto: "QUANTITY_HEART_RATE"),
    27: .same(proto: "QUANTITY_BODY_TEMPERATURE"),
    28: .same(proto: "QUANTITY_BASAL_BODY_TEMPERATURE"),
    29: .same(proto: "QUANTITY_BLOOD_PRESSURE_SYSTOLIC"),
    30: .same(proto: "QUANTITY_BLOOD_PRESSURE_DIASTOLIC"),
    31: .same(proto: "QUANTITY_RESPIRATORY_RATE"),
    32: .same(proto: "QUANTITY_OXYGEN_SATURATION"),
    33: .same(proto: "QUANTITY_PERIPHERAL_PERFUSION_INDEX"),
    34: .same(proto: "QUANTITY_BLOOD_GLUCOSE"),
    35: .same(proto: "QUANTITY_NUMBER_OF_TIMES_FALLEN"),
    36: .same(proto: "QUANTITY_ELECTRODERMAL_ACTIVITY"),
    37: .same(proto: "QUANTITY_INHALER_USAGE"),
    38: .same(proto: "QUANTITY_BLOOD_ALCOHOL_CONTENT"),
    39: .same(proto: "QUANTITY_FORCED_VITAL_CAPACITY"),
    40: .same(proto: "QUANTITY_FORCED_EXPIRATORY_VOLUME1"),
    41: .same(proto: "QUANTITY_PEAK_EXPIRATORY_FLOW_RATE"),
    42: .same(proto: "QUANTITY_DIETARY_FAT_TOTAL"),
    43: .same(proto: "QUANTITY_DIETARY_FAT_POLYUNSATURATED"),
    44: .same(proto: "QUANTITY_DIETARY_FAT_MONOUNSATURATED"),
    45: .same(proto: "QUANTITY_DIETARY_FAT_SATURATED"),
    46: .same(proto: "QUANTITY_DIETARY_CHOLESTEROL"),
    47: .same(proto: "QUANTITY_DIETARY_SODIUM"),
    48: .same(proto: "QUANTITY_DIETARY_CARBOHYDRATES"),
    49: .same(proto: "QUANTITY_DIETARY_FIBER"),
    50: .same(proto: "QUANTITY_DIETARY_SUGAR"),
    51: .same(proto: "QUANTITY_DIETARY_ENERGY_CONSUMED"),
    52: .same(proto: "QUANTITY_DIETARY_PROTEIN"),
    53: .same(proto: "QUANTITY_DIETARY_VITAMIN_A"),
    54: .same(proto: "QUANTITY_DIETARY_VITAMIN_B6"),
    55: .same(proto: "QUANTITY_DIETARY_VITAMIN_B12"),
    56: .same(proto: "QUANTITY_DIETARY_VITAMIN_C"),
    57: .same(proto: "QUANTITY_DIETARY_VITAMIN_D"),
    58: .same(proto: "QUANTITY_DIETARY_VITAMIN_E"),
    59: .same(proto: "QUANTITY_DIETARY_VITAMIN_K"),
    60: .same(proto: "QUANTITY_DIETARY_CALCIUM"),
    61: .same(proto: "QUANTITY_DIETARY_IRON"),
    62: .same(proto: "QUANTITY_DIETARY_THIAMIN"),
    63: .same(proto: "QUANTITY_DIETARY_RIBOFLAVIN"),
    64: .same(proto: "QUANTITY_DIETARY_NIACIN"),
    65: .same(proto: "QUANTITY_DIETARY_FOLATE"),
    66: .same(proto: "QUANTITY_DIETARY_BIOTIN"),
    67: .same(proto: "QUANTITY_DIETARY_PANTOTHENIC_ACID"),
    68: .same(proto: "QUANTITY_DIETARY_PHOSPHORUS"),
    69: .same(proto: "QUANTITY_DIETARY_IODINE"),
    70: .same(proto: "QUANTITY_DIETARY_MAGNESIUM"),
    71: .same(proto: "QUANTITY_DIETARY_ZINC"),
    72: .same(proto: "QUANTITY_DIETARY_SELENIUM"),
    73: .same(proto: "QUANTITY_DIETARY_COPPER"),
    74: .same(proto: "QUANTITY_DIETARY_MANGANESE"),
    75: .same(proto: "QUANTITY_DIETARY_CHROMIUM"),
    76: .same(proto: "QUANTITY_DIETARY_MOLYBDENUM"),
    77: .same(proto: "QUANTITY_DIETARY_CHLORIDE"),
    78: .same(proto: "QUANTITY_DIETARY_POTASSIUM"),
    79: .same(proto: "QUANTITY_DIETARY_CAFFEINE"),
    80: .same(proto: "QUANTITY_DIETARY_WATER"),
    81: .same(proto: "QUANTITY_UV_EXPOSURE"),
    82: .same(proto: "QUANTITY_APPLE_EXERCISE_TIME"),
    83: .same(proto: "QUANTITY_DISTANCE_WHEELCHAIR"),
    84: .same(proto: "QUANTITY_PUSH_COUNT"),
    85: .same(proto: "QUANTITY_DISTANCE_SWIMMING"),
    86: .same(proto: "QUANTITY_SWIMMING_STROKE_COUNT"),
    87: .same(proto: "QUANTITY_WAIST_CIRCUMFERENCE"),
    88: .same(proto: "QUANTITY_VO2_MAX"),
    89: .same(proto: "QUANTITY_RESTING_HEART_RATE"),
    90: .same(proto: "QUANTITY_WALKING_HEART_RATE_AVERAGE"),
    91: .same(proto: "QUANTITY_HEART_RATE_VARIABILITY_SDNN"),
    92: .same(proto: "QUANTITY_INSULIN_DELIVERY"),
    93: .same(proto: "QUANTITY_DISTANCE_DOWNHILL_SNOW_SPORTS"),
    94: .same(proto: "QUANTITY_APPLE_STAND_TIME"),
    95: .same(proto: "QUANTITY_ENVIRONMENTAL_AUDIO_EXPOSURE"),
    96: .same(proto: "QUANTITY_HEADPHONE_AUDIO_EXPOSURE"),
    97: .same(proto: "CHARACTERISTIC_BIOLOGICAL_SEX"),
    98: .same(proto: "CHARACTERISTIC_BLOOD_TYPE"),
    99: .same(proto: "CHARACTERISTIC_DATE_OF_BIRTH"),
    100: .same(proto: "CHARACTERISTIC_FITZPATRICK_SKIN_TYPE"),
    101: .same(proto: "CHARACTERISTIC_WHEELCHAIR_USE"),
    102: .same(proto: "CLINICAL_ALLERGY_RECORD"),
    103: .same(proto: "CLINICAL_CONDITION_RECORD"),
    104: .same(proto: "CLINICAL_IMMUNIZATION_RECORD"),
    105: .same(proto: "CLINICAL_LAB_RESULT_RECORD"),
    106: .same(proto: "CLINICAL_MEDICATION_RECORD"),
    107: .same(proto: "CLINICAL_PROCEDURE_RECORD"),
    108: .same(proto: "CLINICAL_VITAL_SIGN_RECORD"),
    109: .same(proto: "DOCUMENT_CDA"),
    110: .same(proto: "CORRELATION_BLOOD_PRESSURE"),
    111: .same(proto: "CORRELATION_FOOD"),
  ]
}

extension RequestSorting: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DESCENDING_START_DATE"),
    1: .same(proto: "ASCENDING_START_DATE"),
    2: .same(proto: "ASCENDING_END_DATE"),
    3: .same(proto: "DESCENDING_END_DATE"),
  ]
}

extension StatisticsOptions: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISCRETE_AVERAGE"),
    1: .same(proto: "DISCRETE_MIN"),
    2: .same(proto: "DISCRETE_MAX"),
    3: .same(proto: "CUMULATIVE_SUM"),
    4: .same(proto: "MOST_RECENT"),
    5: .same(proto: "DURATION"),
    6: .same(proto: "SEPARATE_BY_SOURCE"),
  ]
}

extension HealthTypeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthTypeList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedEnumField(value: &self.types)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.types.isEmpty {
      try visitor.visitPackedEnumField(value: self.types, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthTypeList, rhs: HealthTypeList) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "startDate"),
    3: .same(proto: "endDate"),
    4: .same(proto: "limit"),
    5: .same(proto: "sorting"),
    6: .same(proto: "units"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.startDate)
      case 3: try decoder.decodeSingularStringField(value: &self.endDate)
      case 4: try decoder.decodeSingularInt32Field(value: &self.limit)
      case 5: try decoder.decodeSingularEnumField(value: &self.sorting)
      case 6: try decoder.decodeRepeatedStringField(value: &self.units)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .workoutMain {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.startDate.isEmpty {
      try visitor.visitSingularStringField(value: self.startDate, fieldNumber: 2)
    }
    if !self.endDate.isEmpty {
      try visitor.visitSingularStringField(value: self.endDate, fieldNumber: 3)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 4)
    }
    if self.sorting != .descendingStartDate {
      try visitor.visitSingularEnumField(value: self.sorting, fieldNumber: 5)
    }
    if !self.units.isEmpty {
      try visitor.visitRepeatedStringField(value: self.units, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthDataRequest, rhs: HealthDataRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.sorting != rhs.sorting {return false}
    if lhs.units != rhs.units {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthDataRequestList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthDataRequestList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requests"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.requests)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requests, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthDataRequestList, rhs: HealthDataRequestList) -> Bool {
    if lhs.requests != rhs.requests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "objectType"),
    3: .same(proto: "startDate"),
    4: .same(proto: "endDate"),
    5: .same(proto: "device"),
    6: .same(proto: "metadata"),
    7: .same(proto: "uuid"),
    8: .same(proto: "source"),
    10: .same(proto: "emptyData"),
    11: .same(proto: "quantityData"),
    12: .same(proto: "categoryData"),
    13: .same(proto: "workoutData"),
    14: .same(proto: "characteristicData"),
    15: .same(proto: "clinicalRecordData"),
    16: .same(proto: "documentData"),
    17: .same(proto: "correlationData"),
  ]

  fileprivate class _StorageClass {
    var _type: HealthTypes = .workoutMain
    var _objectType: String = String()
    var _startDate: String = String()
    var _endDate: String = String()
    var _device: String = String()
    var _metadata: String = String()
    var _uuid: String = String()
    var _source: SourceRevision? = nil
    var _specificData: HealthData.OneOf_SpecificData?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _objectType = source._objectType
      _startDate = source._startDate
      _endDate = source._endDate
      _device = source._device
      _metadata = source._metadata
      _uuid = source._uuid
      _source = source._source
      _specificData = source._specificData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularStringField(value: &_storage._objectType)
        case 3: try decoder.decodeSingularStringField(value: &_storage._startDate)
        case 4: try decoder.decodeSingularStringField(value: &_storage._endDate)
        case 5: try decoder.decodeSingularStringField(value: &_storage._device)
        case 6: try decoder.decodeSingularStringField(value: &_storage._metadata)
        case 7: try decoder.decodeSingularStringField(value: &_storage._uuid)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._source)
        case 10:
          var v: EmptySpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .emptyData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .emptyData(v)}
        case 11:
          var v: QuantitySpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .quantityData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .quantityData(v)}
        case 12:
          var v: CategorySpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .categoryData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .categoryData(v)}
        case 13:
          var v: WorkoutSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .workoutData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .workoutData(v)}
        case 14:
          var v: CharacteristicSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .characteristicData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .characteristicData(v)}
        case 15:
          var v: ClinicalRecordSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .clinicalRecordData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .clinicalRecordData(v)}
        case 16:
          var v: DocumentSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .documentData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .documentData(v)}
        case 17:
          var v: CorrelationSpecificData?
          if let current = _storage._specificData {
            try decoder.handleConflictingOneOf()
            if case .correlationData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._specificData = .correlationData(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .workoutMain {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._objectType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._objectType, fieldNumber: 2)
      }
      if !_storage._startDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._startDate, fieldNumber: 3)
      }
      if !_storage._endDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._endDate, fieldNumber: 4)
      }
      if !_storage._device.isEmpty {
        try visitor.visitSingularStringField(value: _storage._device, fieldNumber: 5)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadata, fieldNumber: 6)
      }
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 7)
      }
      if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      switch _storage._specificData {
      case .emptyData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .quantityData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .categoryData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .workoutData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .characteristicData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .clinicalRecordData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .documentData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .correlationData(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthData, rhs: HealthData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._objectType != rhs_storage._objectType {return false}
        if _storage._startDate != rhs_storage._startDate {return false}
        if _storage._endDate != rhs_storage._endDate {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._specificData != rhs_storage._specificData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthDataList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthDataList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthDataList, rhs: HealthDataList) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EmptySpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EmptySpecificData"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EmptySpecificData, rhs: EmptySpecificData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QuantitySpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "QuantitySpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "count"),
    102: .same(proto: "quantityUnit"),
    103: .same(proto: "quantity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularInt64Field(value: &self.count)
      case 102: try decoder.decodeSingularStringField(value: &self.quantityUnit)
      case 103: try decoder.decodeSingularDoubleField(value: &self.quantity)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 101)
    }
    if !self.quantityUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.quantityUnit, fieldNumber: 102)
    }
    if self.quantity != 0 {
      try visitor.visitSingularDoubleField(value: self.quantity, fieldNumber: 103)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QuantitySpecificData, rhs: QuantitySpecificData) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.quantityUnit != rhs.quantityUnit {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CategorySpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CategorySpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularInt64Field(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CategorySpecificData, rhs: CategorySpecificData) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension WorkoutSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "WorkoutSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "totalEnergyBurned"),
    102: .same(proto: "totalEnergyBurnedUnit"),
    103: .same(proto: "totalDistance"),
    104: .same(proto: "totalDistanceUnit"),
    105: .same(proto: "duration"),
    106: .same(proto: "activityType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularDoubleField(value: &self.totalEnergyBurned)
      case 102: try decoder.decodeSingularStringField(value: &self.totalEnergyBurnedUnit)
      case 103: try decoder.decodeSingularDoubleField(value: &self.totalDistance)
      case 104: try decoder.decodeSingularStringField(value: &self.totalDistanceUnit)
      case 105: try decoder.decodeSingularDoubleField(value: &self.duration)
      case 106: try decoder.decodeSingularInt32Field(value: &self.activityType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalEnergyBurned != 0 {
      try visitor.visitSingularDoubleField(value: self.totalEnergyBurned, fieldNumber: 101)
    }
    if !self.totalEnergyBurnedUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.totalEnergyBurnedUnit, fieldNumber: 102)
    }
    if self.totalDistance != 0 {
      try visitor.visitSingularDoubleField(value: self.totalDistance, fieldNumber: 103)
    }
    if !self.totalDistanceUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.totalDistanceUnit, fieldNumber: 104)
    }
    if self.duration != 0 {
      try visitor.visitSingularDoubleField(value: self.duration, fieldNumber: 105)
    }
    if self.activityType != 0 {
      try visitor.visitSingularInt32Field(value: self.activityType, fieldNumber: 106)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: WorkoutSpecificData, rhs: WorkoutSpecificData) -> Bool {
    if lhs.totalEnergyBurned != rhs.totalEnergyBurned {return false}
    if lhs.totalEnergyBurnedUnit != rhs.totalEnergyBurnedUnit {return false}
    if lhs.totalDistance != rhs.totalDistance {return false}
    if lhs.totalDistanceUnit != rhs.totalDistanceUnit {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.activityType != rhs.activityType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CharacteristicSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CharacteristicSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CharacteristicSpecificData, rhs: CharacteristicSpecificData) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClinicalRecordSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClinicalRecordSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "displayName"),
    102: .same(proto: "fhirResource"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularStringField(value: &self.displayName)
      case 102: try decoder.decodeSingularStringField(value: &self.fhirResource)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 101)
    }
    if !self.fhirResource.isEmpty {
      try visitor.visitSingularStringField(value: self.fhirResource, fieldNumber: 102)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClinicalRecordSpecificData, rhs: ClinicalRecordSpecificData) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.fhirResource != rhs.fhirResource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DocumentSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DocumentSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "authorName"),
    102: .same(proto: "custodianName"),
    103: .same(proto: "documentData"),
    104: .same(proto: "patientName"),
    105: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularStringField(value: &self.authorName)
      case 102: try decoder.decodeSingularStringField(value: &self.custodianName)
      case 103: try decoder.decodeSingularStringField(value: &self.documentData)
      case 104: try decoder.decodeSingularStringField(value: &self.patientName)
      case 105: try decoder.decodeSingularStringField(value: &self.title)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authorName.isEmpty {
      try visitor.visitSingularStringField(value: self.authorName, fieldNumber: 101)
    }
    if !self.custodianName.isEmpty {
      try visitor.visitSingularStringField(value: self.custodianName, fieldNumber: 102)
    }
    if !self.documentData.isEmpty {
      try visitor.visitSingularStringField(value: self.documentData, fieldNumber: 103)
    }
    if !self.patientName.isEmpty {
      try visitor.visitSingularStringField(value: self.patientName, fieldNumber: 104)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 105)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DocumentSpecificData, rhs: DocumentSpecificData) -> Bool {
    if lhs.authorName != rhs.authorName {return false}
    if lhs.custodianName != rhs.custodianName {return false}
    if lhs.documentData != rhs.documentData {return false}
    if lhs.patientName != rhs.patientName {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CorrelationSpecificData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CorrelationSpecificData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "objects"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeRepeatedMessageField(value: &self.objects)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objects.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objects, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CorrelationSpecificData, rhs: CorrelationSpecificData) -> Bool {
    if lhs.objects != rhs.objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SourceRevision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SourceRevision"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "version"),
    102: .same(proto: "operatingSystemVersion"),
    103: .same(proto: "productType"),
    104: .same(proto: "name"),
    105: .same(proto: "bundleIdentifier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 101: try decoder.decodeSingularStringField(value: &self.version)
      case 102: try decoder.decodeSingularStringField(value: &self.operatingSystemVersion)
      case 103: try decoder.decodeSingularStringField(value: &self.productType)
      case 104: try decoder.decodeSingularStringField(value: &self.name)
      case 105: try decoder.decodeSingularStringField(value: &self.bundleIdentifier)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 101)
    }
    if !self.operatingSystemVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.operatingSystemVersion, fieldNumber: 102)
    }
    if !self.productType.isEmpty {
      try visitor.visitSingularStringField(value: self.productType, fieldNumber: 103)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 104)
    }
    if !self.bundleIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.bundleIdentifier, fieldNumber: 105)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SourceRevision, rhs: SourceRevision) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.operatingSystemVersion != rhs.operatingSystemVersion {return false}
    if lhs.productType != rhs.productType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.bundleIdentifier != rhs.bundleIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StatisticsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StatisticsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "startDate"),
    3: .same(proto: "endDate"),
    4: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.startDate)
      case 3: try decoder.decodeSingularStringField(value: &self.endDate)
      case 4: try decoder.decodeRepeatedEnumField(value: &self.options)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .workoutMain {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.startDate.isEmpty {
      try visitor.visitSingularStringField(value: self.startDate, fieldNumber: 2)
    }
    if !self.endDate.isEmpty {
      try visitor.visitSingularStringField(value: self.endDate, fieldNumber: 3)
    }
    if !self.options.isEmpty {
      try visitor.visitPackedEnumField(value: self.options, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StatisticsRequest, rhs: StatisticsRequest) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StatisticsData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StatisticsData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sources"),
    2: .same(proto: "averageQuantity"),
    3: .same(proto: "maximumQuantity"),
    4: .same(proto: "minimumQuantity"),
    5: .same(proto: "sumQuantity"),
    6: .same(proto: "duration"),
    7: .same(proto: "mostRecentQuantity"),
    8: .same(proto: "mostRecentQuantityDateInterval"),
    9: .same(proto: "dataInterval"),
    10: .same(proto: "dataBySource"),
  ]

  fileprivate class _StorageClass {
    var _sources: [SourceRevision] = []
    var _averageQuantity: QuantitySpecificData? = nil
    var _maximumQuantity: QuantitySpecificData? = nil
    var _minimumQuantity: QuantitySpecificData? = nil
    var _sumQuantity: QuantitySpecificData? = nil
    var _duration: QuantitySpecificData? = nil
    var _mostRecentQuantity: QuantitySpecificData? = nil
    var _mostRecentQuantityDateInterval: StatisticsData.TimeInterval? = nil
    var _dataInterval: StatisticsData.TimeInterval? = nil
    var _dataBySource: [StatisticsData.StatisticsDataBySource] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sources = source._sources
      _averageQuantity = source._averageQuantity
      _maximumQuantity = source._maximumQuantity
      _minimumQuantity = source._minimumQuantity
      _sumQuantity = source._sumQuantity
      _duration = source._duration
      _mostRecentQuantity = source._mostRecentQuantity
      _mostRecentQuantityDateInterval = source._mostRecentQuantityDateInterval
      _dataInterval = source._dataInterval
      _dataBySource = source._dataBySource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._sources)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._averageQuantity)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._maximumQuantity)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._minimumQuantity)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._sumQuantity)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._duration)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._mostRecentQuantity)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._mostRecentQuantityDateInterval)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._dataInterval)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._dataBySource)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._sources.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sources, fieldNumber: 1)
      }
      if let v = _storage._averageQuantity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._maximumQuantity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._minimumQuantity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._sumQuantity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._mostRecentQuantity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._mostRecentQuantityDateInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._dataInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._dataBySource.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dataBySource, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StatisticsData, rhs: StatisticsData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sources != rhs_storage._sources {return false}
        if _storage._averageQuantity != rhs_storage._averageQuantity {return false}
        if _storage._maximumQuantity != rhs_storage._maximumQuantity {return false}
        if _storage._minimumQuantity != rhs_storage._minimumQuantity {return false}
        if _storage._sumQuantity != rhs_storage._sumQuantity {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._mostRecentQuantity != rhs_storage._mostRecentQuantity {return false}
        if _storage._mostRecentQuantityDateInterval != rhs_storage._mostRecentQuantityDateInterval {return false}
        if _storage._dataInterval != rhs_storage._dataInterval {return false}
        if _storage._dataBySource != rhs_storage._dataBySource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StatisticsData.StatisticsDataBySource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StatisticsData.protoMessageName + ".StatisticsDataBySource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _source: SourceRevision? = nil
    var _data: StatisticsData? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _source = source._source
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._source)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._data)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StatisticsData.StatisticsDataBySource, rhs: StatisticsData.StatisticsDataBySource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._source != rhs_storage._source {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StatisticsData.TimeInterval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StatisticsData.protoMessageName + ".TimeInterval"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "startDate"),
    4: .same(proto: "endDate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3: try decoder.decodeSingularStringField(value: &self.startDate)
      case 4: try decoder.decodeSingularStringField(value: &self.endDate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startDate.isEmpty {
      try visitor.visitSingularStringField(value: self.startDate, fieldNumber: 3)
    }
    if !self.endDate.isEmpty {
      try visitor.visitSingularStringField(value: self.endDate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StatisticsData.TimeInterval, rhs: StatisticsData.TimeInterval) -> Bool {
    if lhs.startDate != rhs.startDate {return false}
    if lhs.endDate != rhs.endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
